AWSTemplateFormatVersion: "2010-09-09"
Description: Full Defguard stack with Core, Proxy, Gateway, and a Database.
Parameters:
  CoreUrl:
    Type: String
    Description: The URL for the Defguard Core (e.g., https://core.example.com)
  CoreGrpcPort:
    Type: Number
    Default: 50055
    Description: The gRPC port for the Defguard Core
  CoreHttpPort:
    Type: Number
    Default: 8000
    Description: The HTTP port for the Defguard Core web UI
  CoreCookieInsecure:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: Whether to allow insecure cookies for the Defguard Core web UI
  CoreDefaultAdminPassword:
    Type: String
    NoEcho: true
    Description: The initial password for the admin user
  CoreInstanceType:
    Type: String
    Default: t3.micro
    Description: The instance type for the Defguard Core server
  ProxyUrl:
    Type: String
    Description: The URL for the Defguard Proxy (e.g., https://proxy.example.com)
  ProxyGrpcPort:
    Type: Number
    Default: 50051
    Description: The gRPC port for the Defguard Proxy
  ProxyHttpPort:
    Type: Number
    Default: 8000
    Description: The HTTP port for the Defguard Proxy
  ProxyInstanceType:
    Type: String
    Default: t3.micro
    Description: The instance type for the Defguard Proxy server
  GatewayInstanceType:
    Type: String
    Default: t3.micro
    Description: The instance type for the Defguard Gateway server
  DbName:
    Type: String
    Default: defguard
    Description: The name of the database
  DbUsername:
    Type: String
    Default: defguard
    Description: The username for the database
  DbPassword:
    Type: String
    NoEcho: true
    Description: The password for the database user
  DbPort:
    Type: Number
    Default: 5432
    Description: The port on which the database will listen
  DbStorage:
    Type: Number
    Default: 20
    Description: The amount of storage allocated for the database in GB
  DbInstanceClass:
    Type: String
    Default: db.t3.micro
    Description: The instance class for the database
  VpcName:
    Type: String
    Default: defguard-vpc
    Description: The name of the VPC
  VpcCidr:
    Type: String
    Default: 10.0.0.0/16
    Description: The CIDR block for the VPC
  VpnNetworkName:
    Type: String
    Default: vpn1
    Description: The name of the VPN network
  VpnNetworkAddress:
    Type: String
    Default: 10.10.10.1/24
    Description: The CIDR address of the VPN network
  VpnNetworkPort:
    Type: Number
    Default: 51820
    Description: The UDP port for the Gateway to accept VPN connections
  VpnNetworkNat:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: Whether to enable NAT for the VPN network. This may allow VPN clients to access the internet through the Gateway.
  CoreLogLevel:
    Type: String
    Default: info
    AllowedValues:
      - trace
      - debug
      - info
      - warn
      - error
    Description: Log level for Defguard Core component
  ProxyLogLevel:
    Type: String
    Default: info
    AllowedValues:
      - trace
      - debug
      - info
      - warn
      - error
    Description: Log level for Defguard Proxy component
  GatewayLogLevel:
    Type: String
    Default: info
    AllowedValues:
      - trace
      - debug
      - info
      - warn
      - error
    Description: Log level for Defguard Gateway component
  DefguardCoreAmiId:
    Type: String
    Description: (Optional) Custom AMI ID for Defguard Core instance. If not provided, a default AMI will be used based on the region.
    Default: "ami-089e02a9b43e74615"
  SshKeyName:
    Type: String
    Description: (Optional) EC2 Key Pair name for SSH access to instances. If not provided, SSH access will not be available. Requires a manual setup of SSH security group rules afterwards.
    Default: ""
  DefguardProxyVersion:
    Type: String
    Default: "1.5.0"
    Description: Version of Defguard Proxy package to install
  DefguardGatewayVersion:
    Type: String
    Default: "1.5.0"
    Description: Version of Defguard Gateway package to install
Mappings:
  AmiMap:
    us-east-1:
      debian: ami-0702a3ce7f850fb87
    ap-northeast-1:
      debian: ami-023c12e6d24e0a6df
    eu-west-1:
      debian: ami-04034bfd5da1fa2ed
    eu-central-1:
      debian: ami-0aeb8600ead64c406
Conditions:
  UseSshKey: !Not [!Equals [!Ref SshKeyName, ""]]
Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Ref VpcName
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-igw
  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway
  DefguardPublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select
        - 0
        - !GetAZs ""
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-defguard-public-subnet-1
  DefguardPrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select
        - 0
        - !GetAZs ""
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-defguard-private-subnet-1
  DefguardPrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.3.0/24
      AvailabilityZone: !Select
        - 1
        - !GetAZs ""
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-defguard-private-subnet-2
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-public-rt
  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
  DefguardPublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref DefguardPublicSubnet
      RouteTableId: !Ref PublicRouteTable
  NATGatewayEIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-nat-eip
  NATGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NATGatewayEIP.AllocationId
      SubnetId: !Ref DefguardPublicSubnet
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-nat-gateway
  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${VpcName}-private-rt
  PrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NATGateway
  DefguardPrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref DefguardPrivateSubnet1
      RouteTableId: !Ref PrivateRouteTable
  DefguardPrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref DefguardPrivateSubnet2
      RouteTableId: !Ref PrivateRouteTable
  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupName: defguard-db-subnet-group
      DBSubnetGroupDescription: Subnet group for Defguard database
      SubnetIds:
        - !Ref DefguardPrivateSubnet1
        - !Ref DefguardPrivateSubnet2
      Tags:
        - Key: Name
          Value: defguard-db-subnet-group
  DBParameterGroup:
    Type: AWS::RDS::DBParameterGroup
    Properties:
      DBParameterGroupName: defguard-db-parameter-group
      Description: Parameter group for Defguard database
      Family: postgres17
      Parameters:
        rds.force_ssl: "0"
      Tags:
        - Key: Name
          Value: defguard-db-parameter-group
  DatabaseSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: defguard-db-sg
      GroupDescription: Access to the database
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref DbPort
          ToPort: !Ref DbPort
          SourceSecurityGroupId: !Ref CoreSecurityGroup
      Tags:
        - Key: Name
          Value: defguard-db-sg
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: defguard-lambda-sg
      GroupDescription: Lambda function access
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: defguard-lambda-sg
  Database:
    Type: AWS::RDS::DBInstance
    Properties:
      DBName: !Ref DbName
      DBInstanceIdentifier: defguard-core-db
      DBInstanceClass: !Ref DbInstanceClass
      Engine: postgres
      MasterUsername: !Ref DbUsername
      MasterUserPassword: !Ref DbPassword
      Port: !Ref DbPort
      AllocatedStorage: !Ref DbStorage
      DBSubnetGroupName: !Ref DBSubnetGroup
      VPCSecurityGroups:
        - !Ref DatabaseSecurityGroup
      DBParameterGroupName: !Ref DBParameterGroup
      DeletionProtection: false
      BackupRetentionPeriod: 0
      Tags:
        - Key: Name
          Value: defguard-core-db
  CoreSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: defguard-core-sg
      GroupDescription: Core access
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref CoreHttpPort
          ToPort: !Ref CoreHttpPort
          SourceSecurityGroupId: !Ref GatewaySecurityGroup
          Description: HTTP access from gateways
        - IpProtocol: tcp
          FromPort: !Ref CoreGrpcPort
          ToPort: !Ref CoreGrpcPort
          SourceSecurityGroupId: !Ref GatewaySecurityGroup
          Description: gRPC communication with gateways
        - IpProtocol: tcp
          FromPort: !Ref CoreHttpPort
          ToPort: !Ref CoreHttpPort
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          Description: HTTP access from Lambda function
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: defguard-core-sg
  ProxySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: defguard-proxy-sg
      GroupDescription: Proxy access
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref ProxyHttpPort
          ToPort: !Ref ProxyHttpPort
          CidrIp: 0.0.0.0/0
          Description: HTTP access to proxy
        - IpProtocol: tcp
          FromPort: !Ref ProxyGrpcPort
          ToPort: !Ref ProxyGrpcPort
          SourceSecurityGroupId: !Ref CoreSecurityGroup
          Description: Internal communication with core
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: defguard-proxy-sg
  GatewaySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: defguard-gateway-sg
      GroupDescription: Gateway access
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: udp
          FromPort: !Ref VpnNetworkPort
          ToPort: !Ref VpnNetworkPort
          CidrIp: 0.0.0.0/0
          Description: VPN traffic from clients
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: defguard-gateway-sg
  CoreNetworkInterface:
    Type: AWS::EC2::NetworkInterface
    Properties:
      SubnetId: !Ref DefguardPrivateSubnet1
      GroupSet:
        - !Ref CoreSecurityGroup
      Tags:
        - Key: Name
          Value: defguard-core-network-interface
  ProxyNetworkInterface:
    Type: AWS::EC2::NetworkInterface
    Properties:
      SubnetId: !Ref DefguardPublicSubnet
      GroupSet:
        - !Ref ProxySecurityGroup
      Tags:
        - Key: Name
          Value: defguard-proxy-network-interface
  GatewayNetworkInterface:
    Type: AWS::EC2::NetworkInterface
    Properties:
      SubnetId: !Ref DefguardPublicSubnet
      GroupSet:
        - !Ref GatewaySecurityGroup
      Tags:
        - Key: Name
          Value: defguard-gateway-network-interface
  ProxyElasticIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: defguard-proxy-eip
  GatewayElasticIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: defguard-gateway-eip
  ProxyEIPAssociation:
    Type: AWS::EC2::EIPAssociation
    Properties:
      NetworkInterfaceId: !Ref ProxyNetworkInterface
      AllocationId: !GetAtt ProxyElasticIP.AllocationId
  GatewayEIPAssociation:
    Type: AWS::EC2::EIPAssociation
    Properties:
      NetworkInterfaceId: !Ref GatewayNetworkInterface
      AllocationId: !GetAtt GatewayElasticIP.AllocationId
  CoreInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref DefguardCoreAmiId
      InstanceType: !Ref CoreInstanceType
      KeyName: !If [UseSshKey, !Ref SshKeyName, !Ref "AWS::NoValue"]
      NetworkInterfaces:
        - NetworkInterfaceId: !Ref CoreNetworkInterface
          DeviceIndex: "0"
      UserData:
        Fn::Base64:
          Fn::Sub: |
            #!/bin/bash
            set -e
            LOG_FILE="/var/log/defguard.log"

            log() {
                echo "$(date '+%Y-%m-%d %H:%M:%S') $1"
            }

            generate_secret_inner() {
                local length="$1"
                openssl rand -base64 "$length" | tr -d "=+/" | tr -d '\n' | cut -c1-"$length"
            }

            (
            log "Writing Core configuration to /etc/defguard/core.conf..."
            mkdir -p /etc/defguard
            tee /etc/defguard/core.conf <<EOF
            ### Core configuration ###
            DEFGUARD_AUTH_SECRET=$(generate_secret_inner 64)
            DEFGUARD_GATEWAY_SECRET=${GeneratedGatewaySecret.GatewaySecret}
            DEFGUARD_YUBIBRIDGE_SECRET=$(generate_secret_inner 64)
            DEFGUARD_SECRET_KEY=$(generate_secret_inner 64)
            DEFGUARD_URL=${CoreUrl}
            DEFGUARD_AUTH_SESSION_LIFETIME=604800
            DEFGUARD_ADMIN_GROUPNAME=admin
            DEFGUARD_DEFAULT_ADMIN_PASSWORD=${CoreDefaultAdminPassword}
            DEFGUARD_GRPC_PORT=${CoreGrpcPort}
            DEFGUARD_HTTP_PORT=${CoreHttpPort}
            DEFGUARD_COOKIE_INSECURE=${CoreCookieInsecure}
            DEFGUARD_LOG_LEVEL=${CoreLogLevel}

            ### Proxy configuration ###
            DEFGUARD_PROXY_URL=http://${ProxyNetworkInterface.PrimaryPrivateIpAddress}:${ProxyGrpcPort}
            DEFGUARD_ENROLLMENT_URL=${ProxyUrl}

            ### DB configuration ###
            DEFGUARD_DB_HOST="${Database.Endpoint.Address}"
            DEFGUARD_DB_PORT=${DbPort}
            DEFGUARD_DB_NAME="${DbName}"
            DEFGUARD_DB_USER="${DbUsername}"
            DEFGUARD_DB_PASSWORD="${DbPassword}"
            EOF

            log "Enabling defguard service..."
            systemctl enable defguard

            log "Starting defguard service..."
            systemctl start defguard

            log "Creating VPN location with address ${VpnNetworkAddress} and endpoint ${GatewayElasticIP} and port ${VpnNetworkPort}..."
            export $(grep -v '^#' /etc/defguard/core.conf | xargs) && /usr/bin/defguard --secret-key ${GeneratedGatewaySecret.GatewaySecret} init-vpn-location --name ${VpnNetworkName} --address ${VpnNetworkAddress} --endpoint ${GatewayElasticIP} --port ${VpnNetworkPort} --id 1 --allowed-ips ${VpnNetworkAddress} --allowed-ips ${VpcCidr} >> "$LOG_FILE" 2>&1

            log "Created VPN location ${VpnNetworkName} with address ${VpnNetworkAddress} and endpoint ${GatewayElasticIP} and port ${VpnNetworkPort}"

            log "Setup completed."
            ) 2>&1 | tee -a "$LOG_FILE"
      Tags:
        - Key: Name
          Value: defguard-core-instance
    DependsOn:
      - Database
      - GeneratedGatewaySecret
  ProxyInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !FindInMap
        - AmiMap
        - !Ref AWS::Region
        - debian
      InstanceType: !Ref ProxyInstanceType
      KeyName: !If [UseSshKey, !Ref SshKeyName, !Ref "AWS::NoValue"]
      NetworkInterfaces:
        - NetworkInterfaceId: !Ref ProxyNetworkInterface
          DeviceIndex: "0"
      UserData:
        Fn::Base64:
          Fn::Sub: |
            #!/bin/bash
            set -e
            LOG_FILE="/var/log/defguard.log"

            log() {
                echo "$(date '+%Y-%m-%d %H:%M:%S') $1"
            }

            (
            log "Updating apt repositories..."
            apt update

            log "Installing curl..."
            apt install -y curl

            log "Downloading defguard-proxy package..."
            curl -fsSL -o /tmp/defguard-proxy.deb https://github.com/Defguard/proxy/releases/download/v${DefguardProxyVersion}/defguard-proxy-${DefguardProxyVersion}-x86_64-unknown-linux-gnu.deb

            log "Installing defguard-proxy package..."
            dpkg -i /tmp/defguard-proxy.deb

            log "Writing proxy configuration to /etc/defguard/proxy.toml..."
            mkdir -p /etc/defguard
            tee /etc/defguard/proxy.toml <<EOF
            # port the API server will listen on
            http_port = ${ProxyHttpPort}
            # port the gRPC server will listen on
            grpc_port = ${ProxyGrpcPort}

            log_level = "${ProxyLogLevel}"
            rate_limit_per_second = 0
            rate_limit_burst = 0
            url = "${ProxyUrl}"

            EOF

            log "Enabling defguard-proxy service..."
            systemctl enable defguard-proxy

            log "Starting defguard-proxy service..."
            systemctl start defguard-proxy

            log "Setup completed."
            ) 2>&1 | tee -a "$LOG_FILE"
      Tags:
        - Key: Name
          Value: defguard-proxy-instance
  GatewayInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !FindInMap
        - AmiMap
        - !Ref AWS::Region
        - debian
      InstanceType: !Ref GatewayInstanceType
      KeyName: !If [UseSshKey, !Ref SshKeyName, !Ref "AWS::NoValue"]
      NetworkInterfaces:
        - NetworkInterfaceId: !Ref GatewayNetworkInterface
          DeviceIndex: "0"
      UserData:
        Fn::Base64:
          Fn::Sub:
          - |
            #!/bin/bash
            set -e
            LOG_FILE="/var/log/defguard.log"

            log() {
                echo "$(date '+%Y-%m-%d %H:%M:%S') $1"
            }

            base64url_encode() {
                echo -n "$1" | openssl base64 -e -A | tr '+/' '-_' | tr -d '='
            }

            (
            log "Updating apt repositories..."
            apt update

            log "Installing curl..."
            apt install -y curl

            log "Downloading defguard-gateway package..."
            curl -fsSL -o /tmp/defguard-gateway.deb https://github.com/Defguard/gateway/releases/download/v${DefguardGatewayVersion}/defguard-gateway_${DefguardGatewayVersion}_x86_64-unknown-linux-gnu.deb

            log "Installing defguard-gateway package..."
            dpkg -i /tmp/defguard-gateway.deb

            log "Generating gateway token..."
            NETWORK_ID="1"
            SECRET="${GeneratedGatewaySecret.GatewaySecret}"
            ISSUER="Defguard"

            HEADER='{"alg":"HS256","typ":"JWT"}'
            NOW=$(date +%s)
            EXPIRATION=$(($NOW + 315360000))
            PAYLOAD=$(cat <<EOF
            {
              "iss": "$ISSUER",
              "sub": "DEFGUARD-NETWORK-$NETWORK_ID",
              "client_id": "$NETWORK_ID",
              "exp": $EXPIRATION,
              "nbf": $NOW
            }
            EOF
            )
            HEADER_B64=$(base64url_encode "$HEADER")
            PAYLOAD_B64=$(base64url_encode "$PAYLOAD")
            SIGNING_INPUT="$HEADER_B64.$PAYLOAD_B64"
            SIGNATURE=$(echo -n "$SIGNING_INPUT" | openssl dgst -sha256 -hmac "$SECRET" -binary | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')

            GATEWAY_TOKEN="$SIGNING_INPUT.$SIGNATURE"

            log "Writing gateway configuration to /etc/defguard/gateway.toml..."
            mkdir -p /etc/defguard
            tee /etc/defguard/gateway.toml <<EOF
            # This is an example config file for defguard VPN gateway
            # To use it fill in actual values for your deployment below

            # Required: secret token generated by defguard
            # NOTE: must replace default with actual value
            token = "$GATEWAY_TOKEN"
            # Required: defguard server gRPC endpoint URL
            # NOTE: must replace default with actual value
            grpc_url = "http://${CorePrivateIP}:${CoreGrpcPort}"
            # Optional: gateway name which will be displayed in defguard web UI
            name = "defguard-gateway-1"
            # Required: use userspace WireGuard implementation (e.g. wireguard-go)
            userspace = false
            # Optional: path to TLS cert file
            # grpc_ca = cert.pem
            # Required: how often should interface stat updates be sent to defguard server (in seconds)
            stats_period = 60
            # Required: name of WireGuard interface
            ifname = "wg0"
            # Optional: write PID to this file
            # pidfile = defguard-gateway.pid
            # Required: enable logging to syslog
            use_syslog = false
            # Required: which syslog facility to use
            syslog_facility = "LOG_USER"
            # Required: which socket to use for logging
            syslog_socket = "/var/run/log"

            # Optional: Command which will be run before bringing interface up
            # Example: Allow all traffic through WireGuard interface:
            #pre_up = "/path/to/iptables -A INPUT -i wg0 -j ACCEPT
            # example with multiple commands - add them to a shell script
            #pre_up = "/path/to/shell /path/to/script"

            # Optional: Command which will be run after bringing interface up
            # Example: Add a default route after WireGuard interface is up:
            #post_up = "/path/to/ip route add default via 192.168.1.1 dev wg0"

            # Optional: Command which will be run before bringing interface down
            # Example: Remove WireGuard-related firewall rules before interface is taken down:
            #pre_down = "/path/to/iptables -D INPUT -i wg0 -j ACCEPT"

            # Optional: Command which will be run after bringing interface down
            # Example: Remove the default route after WireGuard interface is down:
            #post_down = "/pat/to/ip route del default via 192.168.1.1 dev wg0"

            # A HTTP port that will expose the REST HTTP gateway health status
            # STATUS CODES:
            # 200 - Gateway is working and is connected to CORE
            # 503 - gateway works but is not connected to CORE
            #health_port = 55003

            # Optional: Enable automatic masquerading of traffic by the firewall
            masquerade = ${VpnNetworkNat}

            # Optional: Set the priority of the Defguard forward chain
            #fw_priority = 0

            log_level = "${GatewayLogLevel}"
            EOF

            if [ "${VpnNetworkNat}" = "true" ]; then
              log "Enabling IP forwarding for NAT (IPv4)..."
              sysctl -w net.ipv4.ip_forward=1
              grep -q -e '^net.ipv4.ip_forward' /etc/sysctl.conf || echo "net.ipv4.ip_forward = 1" | tee -a /etc/sysctl.conf

              log "Enabling IP forwarding for NAT (IPv6)..."
              sysctl -w net.ipv6.conf.all.forwarding=1
              grep -q -e '^net.ipv6.conf.all.forwarding' /etc/sysctl.conf || echo "net.ipv6.conf.all.forwarding = 1" | tee -a /etc/sysctl.conf
            fi

            log "Reloading systemd daemon to apply changes..."
            systemctl daemon-reload

            log "Enabling defguard-gateway service..."
            systemctl enable defguard-gateway

            log "Starting defguard-gateway service..."
            systemctl start defguard-gateway
            log "testing secret string generation..."

            log "Setup completed."
            ) 2>&1 | tee -a "$LOG_FILE"
          - { CorePrivateIP: !GetAtt CoreNetworkInterface.PrimaryPrivateIpAddress }
      Tags:
        - Key: Name
          Value: defguard-gateway-instance
    DependsOn:
      - CoreInstance
      - GeneratedGatewaySecret

  # Lambda function to call Defguard API for device creation
  DefguardFirstDeviceFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-defguard-device-setup
      Runtime: python3.9
      Handler: index.handler
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !Ref DefguardPrivateSubnet1
      Code:
        ZipFile: |
          import json
          import urllib.request
          import urllib.parse
          import urllib.error
          import time
          
          def send_response(event, context, response_status, response_data=None, physical_resource_id=None):
              if response_data is None:
                  response_data = {}
              
              # Use existing ID for updates/deletes, let CloudFormation generate one for creates
              if physical_resource_id is None and event['RequestType'] != 'Create':
                  physical_resource_id = event.get('PhysicalResourceId', 'DefguardDeviceSetup')
              elif physical_resource_id is None:
                  physical_resource_id = 'DefguardDeviceSetup'
              
              response_url = event['ResponseURL']
              
              response_body = {
                  'Status': response_status,
                  'Reason': f'See CloudWatch Log Stream: {context.log_stream_name}',
                  'PhysicalResourceId': physical_resource_id,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }
              
              json_response_body = json.dumps(response_body).encode('utf-8')
              
              print(f"Sending response to {response_url}")
              print(f"Response body: {json.dumps(response_body, indent=2)}")
              
              try:
                  request = urllib.request.Request(
                      response_url,
                      data=json_response_body,
                      headers={
                          'Content-Type': '',
                          'Content-Length': str(len(json_response_body))
                      },
                      method='PUT'
                  )
                  
                  response = urllib.request.urlopen(request, timeout=30)
                  print(f"Response sent successfully. Status: {response.status}")
                  return True
                  
              except Exception as e:
                  print(f"Failed to send response: {str(e)}")
                  return False
          
          def handler(event, context):
              print(f"Event: {json.dumps(event, indent=2)}")
              
              try:
                  if event['RequestType'] == 'Create':
                      core_ip = event['ResourceProperties']['CoreIP']
                      core_port = event['ResourceProperties']['CorePort']
                      admin_password = event['ResourceProperties']['AdminPassword']
                      
                      max_retries = 5
                      for attempt in range(max_retries):
                          try:
                              print(f"Attempt {attempt + 1}/{max_retries} to create device")
                              token = create_user_device(core_ip, core_port, admin_password)
                              
                              response_data = {
                                  'Token': token,
                                  'Message': 'Device created successfully'
                              }
                              
                              print(f"Sending SUCCESS response with token: {token}")
                              return send_response(event, context, 'SUCCESS', response_data)
                              
                          except Exception as e:
                              print(f"Attempt {attempt + 1} failed: {str(e)}")
                              if attempt < max_retries - 1:
                                  print(f"Waiting 30 seconds before retry...")
                                  time.sleep(30)
                              else:
                                  raise e
                      
                  elif event['RequestType'] in ['Update', 'Delete']:
                      response_data = {'Message': f'{event["RequestType"]} operation completed'}
                      print(f"Sending SUCCESS response for {event['RequestType']}")
                      return send_response(event, context, 'SUCCESS', response_data, event.get('PhysicalResourceId'))
                      
              except Exception as e:
                  error_msg = str(e)
                  print(f"Error occurred: {error_msg}")
                  response_data = {'Error': error_msg}
                  return send_response(event, context, 'FAILED', response_data)
          
          def create_user_device(core_ip, core_port, admin_password):
              base_url = f"http://{core_ip}:{core_port}"
              
              print("Authenticating as admin...")
              auth_data = json.dumps({
                  "username": "admin",
                  "password": admin_password
              }).encode('utf-8')
              
              auth_request = urllib.request.Request(
                  f"{base_url}/api/v1/auth",
                  data=auth_data,
                  headers={
                      'Content-Type': 'application/json',
                      'User-Agent': 'Defguard-CloudFormation-Setup/1.0'
                  },
                  method='POST'
              )
              
              try:
                  auth_response = urllib.request.urlopen(auth_request)
                  if auth_response.status != 200:
                      raise Exception(f"Authentication failed: {auth_response.status}")
              except urllib.error.HTTPError as e:
                  raise Exception(f"Authentication failed: {e.code} - {e.read().decode()}")
              
              session_cookie = None
              for header_name, header_value in auth_response.headers.items():
                  if header_name.lower() == 'set-cookie' and 'defguard_session=' in header_value:
                      session_cookie = header_value.split('defguard_session=')[1].split(';')[0]
                      break
              
              if not session_cookie:
                  raise Exception("No session cookie received from authentication")
              
              print(f"Authentication successful, session cookie: {session_cookie[:20]}...")
              
              print("Creating enrollment token...")
              token_data = json.dumps({
                  "email": "",
                  "send_enrollment_notification": False,
                  "username": "admin"
              }).encode('utf-8')
              
              token_request = urllib.request.Request(
                  f"{base_url}/api/v1/user/admin/start_desktop",
                  data=token_data,
                  headers={
                      'Content-Type': 'application/json',
                      'User-Agent': 'Defguard-CloudFormation-Setup/1.0',
                      'Cookie': f'defguard_session={session_cookie}'
                  },
                  method='POST'
              )
              
              try:
                  token_response = urllib.request.urlopen(token_request)
                  response_data = json.loads(token_response.read().decode('utf-8'))
                  enrollment_token = response_data.get('enrollment_token', 'TOKEN_NOT_FOUND')
                  enrollment_url = response_data.get('enrollment_url', 'URL_NOT_FOUND')
                  print(f"Enrollment token created successfully: {enrollment_token}")
                  print(f"Enrollment URL: {enrollment_url}")
                  return enrollment_token
              except urllib.error.HTTPError as e:
                  error_msg = e.read().decode()
                  print(f"Token creation failed: {e.code} - {error_msg}")
                  return f"API_CALL_FAILED_{e.code}_{error_msg[:50]}"
      Role: !GetAtt DefguardApiRole.Arn
      Timeout: 300
    DependsOn:
      - CoreInstance
      - CoreNetworkInterface
      - NATGateway
      - LambdaSecurityGroup
      - DefguardPrivateSubnet1
      - PrivateRouteTable
      - PrivateRoute
      - DefguardPrivateSubnet1RouteTableAssociation
      - DefguardPrivateSubnet2
      - DefguardPrivateSubnet2RouteTableAssociation
      - InternetGateway
      - VPCGatewayAttachment
      - VPC
      - PublicRouteTable
      - PublicRoute
      - DefguardPublicSubnet
      - DefguardPublicSubnetRouteTableAssociation

  DefguardApiRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole

  # Role for the Gateway Secret Generator Lambda function
  GatewaySecretGeneratorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # Lambda function to generate Gateway Secret
  GatewaySecretGenerator:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-gateway-secret-generator
      Runtime: python3.9
      Handler: index.handler
      Code:
        ZipFile: |
          import json
          import secrets
          import urllib.request
          import urllib.parse
          
          def send_response(event, context, response_status, response_data=None, physical_resource_id=None):
              if response_data is None:
                  response_data = {}
              
              if physical_resource_id is None:
                  physical_resource_id = event.get('PhysicalResourceId', 'GatewaySecretGenerator')
              
              response_url = event['ResponseURL']
              
              response_body = {
                  'Status': response_status,
                  'Reason': f'See CloudWatch Log Stream: {context.log_stream_name}',
                  'PhysicalResourceId': physical_resource_id,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }
              
              json_response_body = json.dumps(response_body).encode('utf-8')
              
              print(f"Sending response to {response_url}")
              # Don't log the full response body as it may contain sensitive data
              print("Response sent to CloudFormation")
              
              try:
                  request = urllib.request.Request(
                      response_url,
                      data=json_response_body,
                      headers={
                          'Content-Type': '',
                          'Content-Length': str(len(json_response_body))
                      },
                      method='PUT'
                  )
                  
                  response = urllib.request.urlopen(request, timeout=30)
                  print(f"Response sent successfully. Status: {response.status}")
                  return True
                  
              except Exception as e:
                  print(f"Failed to send response: {str(e)}")
                  return False
          
          def generate_secret(length=64):
              return secrets.token_urlsafe(length)[:length]
          
          def handler(event, context):
              print(f"Event RequestType: {event.get('RequestType', 'Unknown')}")
              
              try:
                  if event['RequestType'] == 'Create':
                      # Generate a new 64-character secret
                      gateway_secret = generate_secret(64)
                      
                      response_data = {
                          'GatewaySecret': gateway_secret,
                          'Message': 'Gateway secret generated successfully'
                      }
                      
                      print(f"Generated gateway secret.")
                      return send_response(event, context, 'SUCCESS', response_data)
                      
                  elif event['RequestType'] == 'Update':
                      # For updates, keep the existing secret if available, otherwise generate new
                      existing_secret = event.get('PhysicalResourceId', '')
                      if len(existing_secret) == 64:
                          response_data = {
                              'GatewaySecret': existing_secret,
                              'Message': 'Using existing gateway secret'
                          }
                          print("Reusing existing gateway secret")
                      else:
                          gateway_secret = generate_secret(64)
                          response_data = {
                              'GatewaySecret': gateway_secret,
                              'Message': 'Generated new gateway secret for update'
                          }
                          print(f"Generated new gateway secret for update: {gateway_secret[:8]}...{gateway_secret[-8:]} (length: {len(gateway_secret)})")
                      
                      return send_response(event, context, 'SUCCESS', response_data, event.get('PhysicalResourceId'))
                      
                  elif event['RequestType'] == 'Delete':
                      response_data = {'Message': 'Delete operation completed'}
                      print("Gateway secret generator delete operation completed")
                      return send_response(event, context, 'SUCCESS', response_data, event.get('PhysicalResourceId'))
                      
              except Exception as e:
                  error_msg = str(e)
                  print(f"Error occurred: {error_msg}")
                  response_data = {'Error': error_msg}
                  return send_response(event, context, 'FAILED', response_data)
      Role: !GetAtt GatewaySecretGeneratorRole.Arn
      Timeout: 30

  # Custom resource to generate Gateway Secret
  GeneratedGatewaySecret:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt GatewaySecretGenerator.Arn

  DeviceSetup:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt DefguardFirstDeviceFunction.Arn
      CoreIP: !GetAtt CoreNetworkInterface.PrimaryPrivateIpAddress
      CorePort: !Ref CoreHttpPort
      AdminPassword: !Ref CoreDefaultAdminPassword
    DependsOn:
      - CoreInstance

###########################################################################
############################# Template outputs ############################
###########################################################################
Outputs:
  DefguardCorePrivateAddress:
    Description: The IP address of the Defguard Core instance in the internal network
    Value: !GetAtt CoreNetworkInterface.PrimaryPrivateIpAddress
    Export:
      Name: !Sub ${AWS::StackName}-core-private-ip
  DefguardProxyPublicAddress:
    Description: The public IP address of the Defguard Proxy instance
    Value: !Ref ProxyElasticIP
    Export:
      Name: !Sub ${AWS::StackName}-proxy-public-ip
  DefguardProxyPrivateAddress:
    Description: The private IP address of the Defguard Proxy instance
    Value: !GetAtt ProxyNetworkInterface.PrimaryPrivateIpAddress
    Export:
      Name: !Sub ${AWS::StackName}-proxy-private-ip
  DefguardGatewayPublicAddress:
    Description: The public IP address of the Defguard Gateway instance
    Value: !Ref GatewayElasticIP
    Export:
      Name: !Sub ${AWS::StackName}-gateway-public-ip
  DefguardGatewayPrivateAddress:
    Description: The private IP address of the Defguard Gateway instance
    Value: !GetAtt GatewayNetworkInterface.PrimaryPrivateIpAddress
    Export:
      Name: !Sub ${AWS::StackName}-gateway-private-ip
  DatabaseEndpoint:
    Description: The endpoint of the RDS database
    Value: !GetAtt Database.Endpoint.Address
    Export:
      Name: !Sub ${AWS::StackName}-database-endpoint
  VPCId:
    Description: The ID of the VPC
    Value: !Ref VPC
    Export:
      Name: !Sub ${AWS::StackName}-vpc-id
  DefguardPublicSubnetId:
    Description: The ID of the Defguard public subnet
    Value: !Ref DefguardPublicSubnet
    Export:
      Name: !Sub ${AWS::StackName}-defguard-public-subnet-id
  UserDeviceEnrollmentToken:
    Description: Enrollment token for user device
    Value: !GetAtt DeviceSetup.Token
    Export:
      Name: !Sub ${AWS::StackName}-enrollment-token
